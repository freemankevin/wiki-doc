---
title: 容器管理
description: Docker - 容器管理
published: true
date: 2026-01-30T04:06:13.994Z
tags: 
editor: markdown
dateCreated: 2026-01-30T01:31:22.266Z
---

# 容器管理

> Docker 相关的 容器管理 问题收集
{.is-info}


## 默认凭证

| 服务 | 用户名 | 密码 | 备注 |
|-----|--------|------|------|
| Nacos | nacos | nacos | 配置中心登录 |
| MinIO | admin | Minio@123.com | 对象存储 |
| RabbitMQ | admin | Rabbitmq@123.com | 消息队列 |
| PostgreSQL | postgres | Postgres@123.com | 数据库 |
| Elasticsearch | elastic | Elastic@123.com | 搜索引擎 |
| Redis | - | Redis@123.com | 缓存数据库 |
| GeoServer | admin | Geoserver@123.com | 地理信息 |

---

## 环境准备

### 系统要求

```bash
# 操作系统：Linux (Ubuntu 20.04 LTS 或 CentOS 8+)
# CPU: 8 核以上
# 内存: 40GB 以上
# 磁盘: 500GB 以上 (SSD 推荐)
# Docker: 20.10+ 
# Docker Compose: 2.0+

# 查看版本
docker --version
docker compose version
```

### 安装 Docker 和 Docker Compose

```bash
# 1. 卸载旧版本
sudo apt-get remove docker docker-engine docker.io containerd runc

# 2. 安装依赖
sudo apt-get update
sudo apt-get install -y curl gnupg lsb-release

# 3. 添加 Docker 官方 GPG 密钥
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg

# 4. 添加 Docker 仓库
echo \
  "deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu \
  $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null

# 5. 安装 Docker
sudo apt-get update
sudo apt-get install -y docker-ce docker-ce-cli containerd.io docker-compose-plugin

# 6. 启动 Docker
sudo systemctl start docker
sudo systemctl enable docker

# 7. 验证安装
docker run hello-world
```

### 系统优化配置

```bash
# 1. 调整文件描述符限制
sudo tee -a /etc/security/limits.conf > /dev/null <<EOF
* soft nofile 65535
* hard nofile 65535
* soft nproc 65535
* hard nproc 65535
EOF

# 2. 调整虚拟内存和 mmap 数量（Elasticsearch 必需）
sudo tee -a /etc/sysctl.conf > /dev/null <<EOF
vm.max_map_count=262144
fs.file-max=2097152
net.core.somaxconn=65535
EOF
sudo sysctl -p

# 3. 禁用 THP（Transparent Huge Pages）
echo madvise | sudo tee /sys/kernel/mm/transparent_hugepage/enabled

# 4. 验证配置
cat /proc/sys/vm/max_map_count
```

### 目录结构

```bash
# 创建项目目录
mkdir -p /data/docker-services
cd /data/docker-services

# 创建配置和数据目录
mkdir -p conf data/{nginx,nacos,minio,redis,rabbitmq,pgdata,pgbackup,elastic,geoserver}

# 目录树
docker-services/
├── docker-compose.yml
├── .env
├── conf/
│   ├── nginx.conf
│   ├── mime.types
│   ├── web.conf
│   ├── redis.conf
│   ├── nacos-standlone.env
│   ├── nacos-application.properties
│   └── elasticsearch.yml
├── data/
│   ├── nginx/
│   │   ├── html/
│   │   ├── certs/
│   │   └── logs/
│   ├── nacos/
│   │   ├── data/
│   │   └── logs/
│   ├── minio/
│   │   └── data/
│   ├── redis/
│   │   └── data/
│   ├── rabbitmq/
│   │   └── data/
│   ├── pgdata/
│   ├── pgbackup/
│   ├── elastic/
│   │   ├── data/
│   │   ├── logs/
│   │   └── plugins/
│   └── geoserver/
│       └── data/
└── images/
    └── *.tar.gz (可选的离线镜像)
```

---

## Docker Compose 配置详解

### 核心概念

**Docker Compose** 是定义和运行多容器应用的工具，通过 YAML 配置文件声明式地管理整个应用栈。

### 配置文件基本结构

```yaml
version: '3.8'  # Compose 文件版本

services:       # 服务定义
  service_name:
    image: image:tag
    container_name: name
    ports: []
    environment: {}
    volumes: []
    healthcheck: {}
    restart: policy

volumes:        # 数据卷定义（可选）
networks:       # 网络定义（可选）
```

### 关键字解析

| 关键字 | 说明 | 示例 |
|--------|------|------|
| image | 镜像名称和标签 | `nginx:latest` |
| container_name | 容器名称 | `nginx-server` |
| ports | 端口映射 (宿主:容器) | `"80:80"` |
| environment | 环境变量 | `TZ: Asia/Shanghai` |
| env_file | 环境变量文件 | `./conf/nacos.env` |
| volumes | 数据卷挂载 | `./data:/data:rw` |
| command | 启动命令覆盖 | `["redis-server"]` |
| entrypoint | 入口点覆盖 | `["java", "-jar"]` |
| restart | 重启策略 | `always`, `unless-stopped` |
| depends_on | 依赖关系 | `postgres: {condition: service_healthy}` |
| healthcheck | 健康检查 | 见下表 |
| deploy.resources.limits | 资源限制 | `memory: 4096M` |
| privileged | 特权模式 | `true` / `false` |
| ulimits | 系统限制 | `memlock: {soft: -1, hard: -1}` |

### 健康检查配置

```yaml
healthcheck:
  test: ["CMD", "curl", "-f", "http://localhost:8080/health"]
  interval: 30s          # 检查间隔
  timeout: 10s           # 超时时间
  retries: 3             # 失败重试次数
  start_period: 40s      # 启动等待时间
```

**健康检查的三种写法**：

```yaml
# 1. 直接执行命令
test: ["CMD", "curl", "-f", "http://localhost:8080"]

# 2. 通过 shell 执行
test: ["CMD-SHELL", "curl -f http://localhost || exit 1"]

# 3. 禁用健康检查
test: ["NONE"]
```

---

## 各服务详细配置

### 1. Nginx - Web 服务器与反向代理

#### Docker Compose 配置

```yaml
nginx:
  image: "nginx:latest"
  deploy:
    resources:
      limits:
        memory: 4096M 
  container_name: nginx
  ports:
    - "80:80"
    - "443:443"
  environment:
    - TZ=Asia/Shanghai
  healthcheck:
    test: ["CMD", "nginx", "-t"]
    interval: 30s
    timeout: 10s
    retries: 3
  volumes:
     - ./conf/mime.types:/etc/nginx/mime.types:ro
     - ./conf/nginx.conf:/etc/nginx/nginx.conf:ro
     - ./conf/web.conf:/etc/nginx/conf.d/default.conf:ro
     - ./data/nginx/certs:/etc/ssl/private:ro
     - ./data/nginx/html:/usr/share/nginx/html
     - ./data/nginx/logs:/var/log/nginx:rw
  restart: always
```

#### 配置文件详解

**nginx.conf** - 核心配置文件：

```nginx
user  nginx;
worker_processes  auto;          # 自动检测 CPU 核数

error_log  /var/log/nginx/error.log warn;
pid        /var/run/nginx.pid;

events {
    worker_connections  4096;    # 每个 worker 进程最大连接数
    multi_accept on;             # 一次接受多个连接
    use epoll;                   # 高效的事件处理机制
}

http {
    include       /etc/nginx/mime.types;
    default_type  application/octet-stream;

    # 日志格式
    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
                      '$status $body_bytes_sent "$http_referer" '
                      '"$http_user_agent" "$http_x_forwarded_for"';

    access_log  /var/log/nginx/access.log  main;

    # 传输优化
    sendfile        on;           # 高效文件传输
    tcp_nopush     on;            # 积累数据后一次发送
    tcp_nodelay    on;            # 禁用 Nagle 算法，减少延迟

    keepalive_timeout  75;        # 连接保活时间
    keepalive_requests 1000;      # 一个连接最多请求数

    # Gzip 压缩
    gzip  on;
    gzip_min_length 1k;           # 最小压缩文件大小
    gzip_comp_level 4;            # 压缩级别（1-9）
    gzip_types text/plain application/javascript application/x-javascript 
               text/javascript text/xml text/css;
    gzip_disable "MSIE [1-6]\.";  # 禁用 IE6 gzip
    gzip_vary on;                 # 返回 Vary: Accept-Encoding

    # 客户端配置
    client_max_body_size  2000m;  # 最大上传文件大小
    client_header_timeout 1800s;  # 客户端头部超时
    client_body_timeout   1800s;  # 客户端体超时

    # 代理配置
    proxy_connect_timeout 75s;    # 代理连接超时
    proxy_read_timeout    1800s;  # 代理读超时
    proxy_send_timeout    1800s;  # 代理写超时

    # 缓存配置
    proxy_cache_path /var/cache/nginx levels=1:2 keys_zone=my_cache:10m 
                     max_size=10g inactive=60m use_temp_path=off;

    # 额外的 MIME 类型
    types {
        application/javascript  js;
        application/javascript  mjs;
    }

    include /etc/nginx/conf.d/*.conf;
}
```

**web.conf** - 站点配置：

```nginx
server {
    listen 80;
    server_tokens off;           # 隐藏 nginx 版本号
    absolute_redirect off;       # 相对重定向

    location / {
        root   /usr/share/nginx/html/;
        index  index.html index.htm;
    }
}

# HTTPS 配置（注释中提供）
# server {
#     listen 443 ssl http2;
#     server_name yourdomain.com;
#     
#     ssl_certificate     /etc/ssl/private/server.crt;
#     ssl_certificate_key /etc/ssl/private/server.key;
#     
#     ssl_protocols TLSv1.2 TLSv1.3;
#     ssl_ciphers ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305;
#     ssl_prefer_server_ciphers on;
#     ssl_session_cache shared:SSL:10m;
#     ssl_session_timeout 10m;
# }
```

#### 常用操作

```bash
# 测试配置是否有效
docker exec nginx nginx -t

# 重新加载配置（无需重启容器）
docker exec nginx nginx -s reload

# 查看访问日志
docker exec nginx tail -f /var/log/nginx/access.log

# 查看错误日志
docker logs -f nginx
```

---

### 2. Nacos - 服务注册中心与配置管理

#### Docker Compose 配置

```yaml
nacos:
  image: "nacos/nacos-server:v2.5.1"
  deploy:
    resources:
      limits:
        memory: 4096M
  container_name: nacos
  ports:
    - "8848:8848"  # v2 API port
    - "9848:9848"  # v2 gRPC port
    - "9849:9849"  # v2 gRPC port
    - "7848:7848"  # Raft port
    - "8080:8080"  # v3 console port
  env_file:
    - ./conf/nacos-standlone.env
  volumes:
    - /etc/localtime:/etc/localtime:ro
    - ./conf/nacos-application.properties:/home/nacos/conf/application.properties
    - ./data/nacos/data/:/home/nacos/data
    - ./data/nacos/logs/:/home/nacos/logs
  healthcheck:
    test: ["CMD-SHELL", "curl -f http://localhost:8080/nacos/ || curl -f http://localhost:8848/nacos/"]
    interval: 30s
    timeout: 10s
    retries: 3
    start_period: 60s
  restart: always
```

#### 环境变量配置

**nacos-standlone.env**：

```env
# 认证配置
NACOS_AUTH_ENABLE=true
NACOS_AUTH_IDENTITY_KEY=serverIdentity
NACOS_AUTH_IDENTITY_VALUE=security
NACOS_AUTH_TOKEN=SecretKey012345678901234567890123456789012345678901234567890123456789

# 部署配置
NACOS_DEPLOYMENT_TYPE=merged
MODE=standalone
PREFER_HOST_MODE=hostname
```

**nacos-application.properties** - 应用配置：

```properties
# 服务端口
server.servlet.contextPath=/nacos
nacos.server.main.port=${NACOS_APPLICATION_PORT:8848}
nacos.console.port=${NACOS_CONSOLE_PORT:8080}

# 数据库配置（可选，默认内嵌）
spring.sql.init.platform=${SPRING_DATASOURCE_PLATFORM:}

# 日志配置
server.tomcat.accesslog.enabled=true
server.tomcat.accesslog.max-days=30
server.tomcat.basedir=file:.

# 认证配置
nacos.core.auth.enabled=true
nacos.core.auth.username=nacos
nacos.core.auth.password=nacos
nacos.core.auth.caching.enabled=true
nacos.core.auth.server.identity.key=serverIdentity
nacos.core.auth.server.identity.value=security
nacos.core.auth.plugin.nacos.token.secret.key=SecretKey012345678901234567890123456789012345678901234567890123456789
nacos.core.auth.plugin.nacos.token.expire.seconds=18000

# 自动清理空服务
nacos.naming.empty-service.auto-clean=true
nacos.naming.empty-service.clean.initial-delay-ms=50000
nacos.naming.empty-service.clean.period-time-ms=30000

# 安全配置
nacos.security.ignore.urls=/,/error,/**/*.css,/**/*.js,/**/*.html,/**/*.map,/**/*.svg,/**/*.png,/**/*.ico,/console-ui/public/**,/v1/auth/**,/v1/console/health/**,/actuator/**,/v1/console/server/**
```

#### 访问 Nacos

```bash
# 控制台地址
http://localhost:8080/nacos

# API 地址
http://localhost:8848/nacos/v1/auth/login

# 获取 Token
curl -X POST 'http://localhost:8848/nacos/v1/auth/login' \
  -d 'username=nacos&password=nacos'

# 查询配置
curl -X GET "http://localhost:8848/nacos/v1/cs/configs?dataId=app.properties&group=DEFAULT_GROUP" \
  -H "Authorization: Bearer $TOKEN"
```

---

### 3. MinIO - 对象存储服务

#### Docker Compose 配置

```yaml
minio:
  image: "minio/minio:RELEASE.2025-04-22T22-12-26Z"
  container_name: minio
  deploy:
    resources:
      limits:
        memory: 4096M
  ports:
    - "9000:9000"
    - "9001:9001"
  command: server /data --console-address ":9001"
  environment:
    MINIO_ROOT_USER: 'admin'
    MINIO_ROOT_PASSWORD: 'Minio@123.com'
  healthcheck:
    test: ["CMD", "curl", "-f", "http://localhost:9000/minio/health/live"]
    interval: 30s
    timeout: 10s
    retries: 3
    start_period: 30s
  volumes:
    - /etc/localtime:/etc/localtime:ro
    - ./data/minio/data:/data
  restart: always
```

#### 访问 MinIO

```bash
# Web 控制台
http://localhost:9001

# 用户名: admin
# 密码: Minio@123.com

# API 端点
http://localhost:9000

# 创建 bucket
docker exec minio mc mb minio/my-bucket

# 上传文件
docker exec -it minio mc cp /path/to/file minio/my-bucket/

# 列出 bucket 内容
docker exec minio mc ls minio/
```

#### Python 客户端示例

```python
from minio import Minio

client = Minio(
    "localhost:9000",
    access_key="admin",
    secret_key="Minio@123.com",
    secure=False
)

# 创建 bucket
client.make_bucket("my-bucket")

# 上传文件
client.fput_object("my-bucket", "my-object", "local-file.txt")

# 下载文件
client.fget_object("my-bucket", "my-object", "downloaded-file.txt")

# 列出对象
for obj in client.list_objects("my-bucket"):
    print(obj.object_name)
```

---

### 4. Redis - 缓存数据库

#### Docker Compose 配置

```yaml
redis:
  image: "redis:7.4-alpine"
  deploy:
    resources:
      limits:
        memory: 4096M
  container_name: redis
  ports:
    - "6379:6379"
  command: [ "redis-server", "/usr/local/etc/redis/redis.conf"]
  volumes:
    - /etc/localtime:/etc/localtime:ro
    - ./conf/redis.conf:/usr/local/etc/redis/redis.conf
    - ./data/redis/data:/data
  privileged: true
  healthcheck:
    test: ["CMD-SHELL", "redis-cli ping"]
    interval: 10s
    timeout: 5s
    retries: 3
  restart: always
```

#### Redis 配置详解

**redis.conf** 核心参数：

```conf
# 基础配置
dir /data                          # 数据目录
port 6379                          # 监听端口
bind 0.0.0.0                       # 绑定地址
requirepass Redis@123.com          # 连接密码
protected-mode yes                 # 保护模式

# 连接配置
tcp-backlog 1024                   # TCP 连接队列
timeout 0                          # 客户端空闲超时（0 = 无限）
tcp-keepalive 300                  # TCP 保活探针

# 进程配置
daemonize no                       # 容器环境需设为 no
loglevel notice                    # 日志级别
databases 16                       # 数据库数量

# 持久化配置
rdbcompression yes                 # RDB 压缩
rdbchecksum yes                    # RDB 校验和
dbfilename dump.rdb                # RDB 文件名
appendonly yes                     # AOF 持久化
appendfilename "appendonly.aof"    # AOF 文件名
appendfsync everysec               # AOF 同步策略

# AOF 重写
auto-aof-rewrite-percentage 100    # AOF 重写触发百分比
auto-aof-rewrite-min-size 64mb     # AOF 重写最小文件大小

# 内存管理
maxmemory 2gb                      # 最大内存（需根据容器调整）
maxmemory-policy allkeys-lru       # 内存淘汰策略

# 慢查询日志
slowlog-log-slower-than 10000      # 慢查询阈值（微秒）
slowlog-max-len 128                # 慢查询日志最大条数
```

#### 常用操作

```bash
# 连接 Redis
docker exec -it redis redis-cli -a Redis@123.com

# 常用命令
redis-cli> PING                           # 健康检查
redis-cli> INFO                           # 查看统计信息
redis-cli> DBSIZE                         # 数据库大小
redis-cli> FLUSHDB                        # 清空当前数据库
redis-cli> SAVE                           # 同步保存
redis-cli> BGSAVE                         # 后台保存
redis-cli> LASTSAVE                       # 最后保存时间
redis-cli> SLOWLOG GET 10                 # 查看最近 10 条慢查询

# 监控 Redis
docker exec redis redis-cli -a Redis@123.com MONITOR

# 查看内存使用
docker exec redis redis-cli -a Redis@123.com INFO memory
```

#### Python 客户端示例

```python
import redis

# 连接 Redis
r = redis.Redis(
    host='localhost',
    port=6379,
    password='Redis@123.com',
    decode_responses=True
)

# 基础操作
r.set('key', 'value', ex=3600)     # 设置键值，1 小时过期
value = r.get('key')                # 获取值
r.delete('key')                      # 删除键

# 列表操作
r.rpush('list', 'item1', 'item2')
items = r.lrange('list', 0, -1)

# 哈希操作
r.hset('hash', mapping={'field1': 'value1', 'field2': 'value2'})
value = r.hget('hash', 'field1')

# 集合操作
r.sadd('set', 'member1', 'member2')
members = r.smembers('set')

# 有序集合
r.zadd('zset', {'member1': 1, 'member2': 2})
values = r.zrange('zset', 0, -1, withscores=True)
```

---

### 5. RabbitMQ - 消息队列服务

#### Docker Compose 配置

```yaml
rabbitmq:
  image: "rabbitmq:3.13-management-alpine"
  deploy:
    resources:
      limits:
        memory: 4096M
  container_name: rabbitmq
  hostname: rabbitmq
  ports:
    - 5672:5672      # AMQP 端口
    - 15672:15672    # Web 管理界面
  environment:
    TZ: Asia/Shanghai
    RABBITMQ_DEFAULT_USER: "admin"
    RABBITMQ_DEFAULT_PASS: "Rabbitmq@123.com"
  healthcheck:
    test: [ "CMD", "rabbitmqctl", "status"]
    interval: 5s
    timeout: 20s
    retries: 10
  volumes:
    - /etc/localtime:/etc/localtime:ro
    - ./data/rabbitmq/data/:/var/lib/rabbitmq/
  restart: always
```

#### 访问 RabbitMQ

```bash
# Web 管理界面
http://localhost:15672

# 用户名: admin
# 密码: Rabbitmq@123.com

# 连接参数
amqp://admin:Rabbitmq@123.com@localhost:5672/
```

#### 常用操作

```bash
# 进入容器命令行
docker exec -it rabbitmq bash

# rabbitmqctl 命令
rabbitmqctl status                 # 查看状态
rabbitmqctl list_users             # 列出用户
rabbitmqctl list_vhosts            # 列出虚拟主机
rabbitmqctl list_queues            # 列出队列
rabbitmqctl list_exchanges          # 列出交换机

# 创建用户
rabbitmqctl add_user newuser newpass
rabbitmqctl set_permissions -p / newuser ".*" ".*" ".*"

# 删除用户
rabbitmqctl delete_user newuser
```

#### Java 客户端示例

```java
import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.ConnectionFactory;

public class RabbitMQExample {
    public static void main(String[] args) throws Exception {
        ConnectionFactory factory = new ConnectionFactory();
        factory.setHost("localhost");
        factory.setPort(5672);
        factory.setUsername("admin");
        factory.setPassword("Rabbitmq@123.com");
        factory.setVirtualHost("/");

        try (Connection connection = factory.newConnection();
             Channel channel = connection.createChannel()) {
            
            // 声明队列
            String queueName = "my-queue";
            channel.queueDeclare(queueName, true, false, false, null);
            
            // 发送消息
            String message = "Hello RabbitMQ!";
            channel.basicPublish("", queueName, null, message.getBytes());
            System.out.println("消息已发送: " + message);
            
            // 消费消息
            channel.basicConsume(queueName, true, (consumerTag, delivery) -> {
                String msg = new String(delivery.getBody());
                System.out.println("收到消息: " + msg);
            }, consumerTag -> {});
        }
    }
}
```

---

### 6. PostgreSQL - 关系数据库

#### Docker Compose 配置

```yaml
postgres:
  image: "freelabspace/postgresql-postgis:18.1"
  container_name: postgres
  environment:
    - TZ=Asia/Shanghai
    - POSTGRES_DB=postgres
    - POSTGRES_USER=postgres
    - POSTGRES_PASSWORD=Postgres@123.com
  ports:
    - "5432:5432"
  volumes:
    # PG18+ 挂载到 /var/lib/postgresql
    - ./data/pgdata:/var/lib/postgresql
  healthcheck:
    test: ["CMD", "pg_isready", "-U", "postgres"]
    interval: 30s
    timeout: 30s
    retries: 3
    start_period: 5s
  restart: unless-stopped
```

#### 常用操作

```bash
# 连接数据库
docker exec -it postgres psql -U postgres -d postgres

# 常用 SQL 命令
postgres=# \l                      # 列出数据库
postgres=# \dt                     # 列出表
postgres=# \du                     # 列出用户
postgres=# CREATE DATABASE mydb;   # 创建数据库
postgres=# CREATE USER myuser WITH PASSWORD 'password';
postgres=# GRANT ALL PRIVILEGES ON DATABASE mydb TO myuser;
postgres=# \q                      # 退出

# 备份数据库
docker exec postgres pg_dump -U postgres mydb > backup.sql

# 恢复数据库
docker exec -i postgres psql -U postgres mydb < backup.sql

# 查看 PostGIS 扩展
docker exec postgres psql -U postgres -c "CREATE EXTENSION IF NOT EXISTS postgis;"
```

#### Python 客户端示例

```python
import psycopg2

# 连接数据库
conn = psycopg2.connect(
    host="localhost",
    port=5432,
    database="postgres",
    user="postgres",
    password="Postgres@123.com"
)

cursor = conn.cursor()

# 创建表
cursor.execute("""
    CREATE TABLE IF NOT EXISTS users (
        id SERIAL PRIMARY KEY,
        name VARCHAR(100),
        email VARCHAR(100)
    )
""")

# 插入数据
cursor.execute("INSERT INTO users (name, email) VALUES (%s, %s)", 
               ("John Doe", "john@example.com"))

# 查询数据
cursor.execute("SELECT * FROM users")
for row in cursor.fetchall():
    print(row)

conn.commit()
cursor.close()
conn.close()
```

---

### 7. PostgreSQL Backup - 自动备份服务

#### Docker Compose 配置

```yaml
pgbackup:
  image: "freelabspace/postgresql-backup:latest"
  container_name: pgbackup
  environment:
    TZ: Asia/Shanghai
    PG_HOST: postgres
    PG_PORT: 5432
    PG_USER: postgres
    PG_PASSWORD: Postgres@123.com
    PG_DATABASE: postgres,mydb,testdb  # 多数据库用逗号分隔
    BACKUP_RETENTION_DAYS: 7           # 保留 7 天
    BACKUP_TIME: "03:00"               # 每天凌晨 3 点执行
    BACKUP_INTERVAL: daily             # 每日备份
    ENABLE_COMPRESSION: "true"         # 启用压缩
    BACKUP_FORMAT: "both"              # 同时生成 SQL 和 custom 格式
    BACKUP_DIR: /backups               # 备份目录
  volumes:
    - ./data/pgbackup:/backups
  depends_on:
    postgres:
      condition: service_healthy
  restart: unless-stopped
```

#### 备份验证

```bash
# 查看备份文件
ls -lah ./data/pgbackup/

# 查看备份日志
docker logs pgbackup

# 手动触发备份
docker exec pgbackup /backup.sh

# 恢复备份
docker exec -i postgres pg_restore -U postgres -d mydb < ./data/pgbackup/backup.dump
```

---

### 8. Elasticsearch - 全文搜索引擎

#### Docker Compose 配置

```yaml
elastic:
  image: "elasticsearch:8.17.0"
  container_name: elastic
  deploy:
    resources:
      limits:
        memory: 4096M
  environment:
    TZ: Asia/Shanghai
    ELASTIC_PASSWORD: "Elastic@123.com"  
    ES_JAVA_OPTS: "-Xms2g -Xmx2g"         # JVM 内存配置
  ports:
    - "9200:9200"
  volumes:
    - /etc/localtime:/etc/localtime:ro
    - ./data/elastic/data:/usr/share/elasticsearch/data
    - ./data/elastic/logs:/usr/share/elasticsearch/logs
    - ./data/elastic/plugins:/usr/share/elasticsearch/plugins
    - ./conf/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml
  ulimits:
    memlock:
      soft: -1
      hard: -1
  restart: always
```

#### Elasticsearch 配置详解

**elasticsearch.yml**：

```yaml
# 集群和节点配置
cluster.name: "es-server"          # 集群名称
node.name: "single-node"           # 节点名称
node.roles: [master, data, ingest] # 节点角色
discovery.type: single-node        # 单节点模式

# 网络配置
network.host: 0.0.0.0
http.port: 9200
path.logs: /usr/share/elasticsearch/logs

# CORS 配置
http.cors.enabled: true
http.cors.allow-origin: "*"

# 安全配置
xpack.security.enabled: true
xpack.security.http.ssl.enabled: false
xpack.security.transport.ssl.enabled: false

# 内存锁定
bootstrap.memory_lock: true

# 快照仓库
path.repo: ["/usr/share/elasticsearch/snapshots"]
```

#### 常用操作

```bash
# 检查集群健康状态
curl -u elastic:Elastic@123.com http://localhost:9200/_cluster/health

# 创建索引
curl -u elastic:Elastic@123.com -X PUT http://localhost:9200/my-index \
  -H 'Content-Type: application/json' \
  -d '{
    "settings": {
      "number_of_shards": 1,
      "number_of_replicas": 0
    }
  }'

# 插入文档
curl -u elastic:Elastic@123.com -X POST http://localhost:9200/my-index/_doc \
  -H 'Content-Type: application/json' \
  -d '{
    "title": "文档标题",
    "content": "文档内容"
  }'

# 查询文档
curl -u elastic:Elastic@123.com -X GET "http://localhost:9200/my-index/_search" \
  -H 'Content-Type: application/json' \
  -d '{
    "query": {
      "match": {
        "title": "标题"
      }
    }
  }'

# 查看索引
curl -u elastic:Elastic@123.com http://localhost:9200/_cat/indices

# 删除索引
curl -u elastic:Elastic@123.com -X DELETE http://localhost:9200/my-index
```

#### Python 客户端示例

```python
from elasticsearch import Elasticsearch

# 连接 Elasticsearch
es = Elasticsearch(['http://localhost:9200'], basic_auth=('elastic', 'Elastic@123.com'))

# 创建索引
es.indices.create(index='my-index', ignore=400)

# 插入文档
es.index(index='my-index', id=1, document={
    'title': '文档标题',
    'content': '文档内容',
    'author': '作者',
    'timestamp': '2024-01-30'
})

# 搜索
result = es.search(index='my-index', query={
    'match': {
        'title': '标题'
    }
})

for hit in result['hits']['hits']:
    print(hit['_source'])

# 删除文档
es.delete(index='my-index', id=1)

# 删除索引
es.indices.delete(index='my-index')
```

---

### 9. GeoServer - 地理信息服务

#### Docker Compose 配置

```yaml
geoserver:
  image: "kartoza/geoserver:2.27.0"
  container_name: geoserver
  deploy:
    resources:
      limits:
        memory: 4096M
  ports:
    - "8081:8080"
  environment:
    TIMEZONE: 'Asia/Shanghai'
    GEOSERVER_DATA_DIR: /opt/geoserver/data
    GEOSERVER_ADMIN_USER: "admin"
    GEOSERVER_ADMIN_PASSWORD: "Geoserver@123.com"
  volumes:
   - ./data/geoserver/data:/opt/geoserver/data
  restart: always
```

#### 访问 GeoServer

```bash
# Web 控制台
http://localhost:8081/geoserver

# 用户名: admin
# 密码: Geoserver@123.com

# REST API
http://localhost:8081/geoserver/rest
```

#### 常用操作

```bash
# 创建工作区
curl -u admin:Geoserver@123.com -X POST \
  -H "Content-Type: application/json" \
  -d '{"workspace":{"name":"my-workspace"}}' \
  http://localhost:8081/geoserver/rest/workspaces

# 连接数据存储
curl -u admin:Geoserver@123.com -X POST \
  -H "Content-Type: application/json" \
  -d '{
    "dataStore": {
      "name": "my-datastore",
      "connectionParameters": {
        "dbtype": "postgis",
        "host": "postgres",
        "port": "5432",
        "database": "geoserver",
        "user": "postgres",
        "passwd": "Postgres@123.com"
      }
    }
  }' \
  http://localhost:8081/geoserver/rest/workspaces/my-workspace/datastores

# 发布图层
curl -u admin:Geoserver@123.com -X POST \
  -H "Content-Type: application/json" \
  -d '{
    "featureType": {
      "name": "my-layer"
    }
  }' \
  http://localhost:8081/geoserver/rest/workspaces/my-workspace/datastores/my-datastore/featuretypes
```

---

## 容器管理常用命令

### 启动和停止服务

```bash
# 启动所有服务
docker compose up -d

# 启动特定服务
docker compose up -d nginx redis

# 停止所有服务
docker compose down

# 停止特定服务
docker compose stop nginx

# 重启服务
docker compose restart nginx

# 查看服务状态
docker compose ps

# 查看详细状态
docker compose ps -a
```

### 日志查看

```bash
# 查看所有容器日志
docker compose logs

# 实时查看日志
docker compose logs -f

# 查看特定容器日志
docker compose logs -f nginx

# 查看最后 100 行日志
docker compose logs --tail=100 nginx

# 从特定时间开始查看
docker compose logs --since 2024-01-30T10:00:00 nginx
```

### 容器交互

```bash
# 进入容器 shell
docker exec -it nginx bash

# 执行容器内的命令
docker exec nginx nginx -t

# 复制文件到容器
docker cp ./local-file container-name:/path/to/file

# 复制文件从容器
docker cp container-name:/path/to/file ./local-file
```

### 资源管理

```bash
# 查看容器资源使用情况
docker stats

# 查看特定容器的详细信息
docker inspect nginx

# 查看容器进程
docker top nginx

# 查看容器端口映射
docker port nginx
```

### 镜像管理

```bash
# 列出所有镜像
docker images

# 查看镜像详细信息
docker inspect nginx:latest

# 删除镜像
docker rmi nginx:latest

# 清理未使用的镜像
docker image prune -a

# 保存镜像到文件
docker save nginx:latest -o nginx.tar.gz

# 从文件加载镜像
docker load -i nginx.tar.gz
```

### 数据卷管理

```bash
# 列出所有数据卷
docker volume ls

# 查看数据卷详细信息
docker volume inspect docker-services_redis_data

# 删除未使用的数据卷
docker volume prune

# 备份数据卷
docker run --rm -v redis_data:/data -v $(pwd):/backup \
  alpine tar czf /backup/redis-backup.tar.gz -C /data .

# 恢复数据卷
docker run --rm -v redis_data:/data -v $(pwd):/backup \
  alpine tar xzf /backup/redis-backup.tar.gz -C /data
```

---

## 最佳实践

### 1. 使用 .env 文件管理环境变量

**.env** 文件示例：

```env
# 时区
TZ=Asia/Shanghai

# 内存限制
MEMORY_LIMIT_NGINX=4096M
MEMORY_LIMIT_NACOS=4096M
MEMORY_LIMIT_REDIS=4096M

# 数据库
POSTGRES_USER=postgres
POSTGRES_PASSWORD=Postgres@123.com
POSTGRES_DB=postgres

# Redis
REDIS_PASSWORD=Redis@123.com

# 其他服务密码
MINIO_PASSWORD=Minio@123.com
RABBITMQ_PASSWORD=Rabbitmq@123.com
ELASTICSEARCH_PASSWORD=Elastic@123.com
```

在 docker-compose.yml 中引用：

```yaml
services:
  postgres:
    environment:
      POSTGRES_USER: ${POSTGRES_USER}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
```

### 2. 健康检查

总是为关键服务配置健康检查：

```yaml
healthcheck:
  test: ["CMD", "curl", "-f", "http://localhost:8080/health"]
  interval: 30s
  timeout: 10s
  retries: 3
  start_period: 60s  # 启动等待时间
```

### 3. 资源限制

为每个容器设置内存限制：

```yaml
deploy:
  resources:
    limits:
      memory: 4096M
    reservations:
      memory: 2048M
```

### 4. 重启策略

| 策略 | 说明 | 适用场景 |
|-----|------|--------|
| no | 不自动重启 | 一次性任务 |
| always | 总是重启 | 生产服务 |
| unless-stopped | 除非被显式停止，否则重启 | 生产服务 |
| on-failure | 只在失败时重启 | 可选 |

### 5. 日志驱动

```yaml
services:
  nginx:
    logging:
      driver: "json-file"
      options:
        max-size: "100m"
        max-file: "10"
```

### 6. 网络隔离

```yaml
networks:
  internal:
    driver: bridge
    ipam:
      config:
        - subnet: 172.20.0.0/16

services:
  nginx:
    networks:
      - internal
  postgres:
    networks:
      - internal
```

### 7. 数据备份策略

```bash
# 定期备份关键数据
#!/bin/bash
BACKUP_DIR="/data/backups"
DATE=$(date +%Y%m%d_%H%M%S)

# PostgreSQL 备份
docker exec postgres pg_dump -U postgres postgres | \
  gzip > "$BACKUP_DIR/postgres_$DATE.sql.gz"

# Redis 备份
docker exec redis redis-cli -a Redis@123.com BGSAVE

# MinIO 备份
docker exec minio mc mirror minio/my-bucket \
  /data/backups/minio_$DATE

# 删除 7 天前的备份
find "$BACKUP_DIR" -mtime +7 -delete
```

---

## 常见问题与排查

### Q1: 容器启动失败，怎样排查？

```bash
# 查看容器日志
docker compose logs -f nginx

# 查看容器详细信息
docker inspect nginx

# 测试容器网络连接
docker exec nginx ping redis

# 验证数据卷挂载
docker exec nginx ls -la /etc/nginx/
```

### Q2: Elasticsearch 启动报 "max virtual memory" 错误

```bash
# 解决方案：调整系统参数
sudo sysctl -w vm.max_map_count=262144

# 永久生效
echo "vm.max_map_count=262144" | sudo tee -a /etc/sysctl.conf
sudo sysctl -p
```

### Q3: 容器之间无法通信

```bash
# 检查网络
docker network ls
docker network inspect docker-services_default

# 在一个容器内测试连接
docker exec nginx ping postgres

# 检查防火墙
sudo ufw status
sudo ufw allow from any to any port 5432
```

### Q4: 数据卷权限问题

```bash
# 修复权限
docker exec postgres chown -R postgres:postgres /var/lib/postgresql

# 或者使用 chown 镜像
docker run --rm -v ./data:/data alpine chown -R 1000:1000 /data
```

### Q5: 端口已被占用

```bash
# 查看占用的进程
sudo lsof -i :8080

# 杀死进程
sudo kill -9 <PID>

# 或者修改 docker-compose.yml 中的端口映射
ports:
  - "8090:8080"
```

### Q6: 容器占用磁盘空间过大

```bash
# 查看镜像大小
docker images --format "table {{.Repository}}\t{{.Size}}"

# 查看容器日志大小
docker ps -a --no-trunc | awk '{print $NF}' | \
  xargs -I {} du -sh /var/lib/docker/containers/{}/

# 清理日志
truncate -s 0 /var/lib/docker/containers/*/*-json.log

# 清理未使用资源
docker system prune -a
```

### Q7: 内存溢出，容器被杀死

```bash
# 增加内存限制
deploy:
  resources:
    limits:
      memory: 8192M  # 增加到 8GB

# 或者调整应用参数
environment:
  ES_JAVA_OPTS: "-Xms4g -Xmx4g"  # 增加 JVM 内存
```

### Q8: 连接超时问题

```bash
# 检查服务是否正常运行
docker compose ps

# 查看健康检查状态
docker inspect --format='{{.State.Health.Status}}' nginx

# 增加超时时间
healthcheck:
  timeout: 30s  # 增加超时
  start_period: 120s  # 增加启动等待时间
```

---

## 监控和日志管理

### 使用 docker-compose 内置监控

```bash
# 实时监控所有容器
watch -n 1 'docker stats --no-stream'

# 监控特定容器
docker stats nginx postgres

# 导出 CSV 格式
docker stats --no-stream --format "{{json .}}" | jq > stats.json
```

### 日志轮转配置

在 docker-compose.yml 中为所有服务添加：

```yaml
services:
  nginx:
    logging:
      driver: "json-file"
      options:
        max-size: "100m"
        max-file: "10"
        labels: "service=nginx"
```

### 集中式日志管理

使用 ELK Stack 来收集日志：

```yaml
logstash:
  image: "docker.elastic.co/logstash/logstash:8.17.0"
  volumes:
    - ./conf/logstash.conf:/usr/share/logstash/pipeline/logstash.conf:ro
  environment:
    - ES_HOSTS=http://elastic:9200
    - ELASTICSEARCH_USERNAME=elastic
    - ELASTICSEARCH_PASSWORD=Elastic@123.com
  depends_on:
    - elastic

kibana:
  image: "docker.elastic.co/kibana/kibana:8.17.0"
  ports:
    - "5601:5601"
  environment:
    - ELASTICSEARCH_HOSTS=http://elastic:9200
    - ELASTICSEARCH_USERNAME=elastic
    - ELASTICSEARCH_PASSWORD=Elastic@123.com
  depends_on:
    - elastic
```

### 性能监控指标

关键指标：

| 指标 | 说明 | 告警阈值 |
|-----|------|---------|
| CPU 使用率 | 平均值 | > 80% |
| 内存使用率 | 平均值 | > 85% |
| 磁盘使用率 | 数据卷 | > 80% |
| 文件描述符 | 打开数 | > 80% |
| 连接数 | TCP/UDP | > 10000 |
| 响应时间 | p95 延迟 | > 1s |

---

## 总结

本指南覆盖了生产级别 Docker 容器化部署的完整工作流：

✅ 系统准备和优化  
✅ Docker Compose 配置详解  
✅ 9 个核心服务的部署和配置  
✅ 常用管理命令  
✅ 最佳实践和注意事项  
✅ 常见问题排查  
✅ 监控和日志管理  

通过遵循本指南，你可以快速部署和管理复杂的微服务系统。

祝你的容器化之旅顺利！